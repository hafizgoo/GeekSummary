总结：

<p align="left">&ensp;&ensp;经过了15周的学习，终于完成了Java进阶营的学习，非常的开心。参加这个训练营的最初的目的是为了建立自己的知识体系框架，做了几年的java开发的工作了，一直有接触各种知识，但是一直无法跳出来看到知识的全貌，知识孤立而未成体系。经过这次的学习，终于在老师的带领下，慢慢建立自己的知识体系了。</p>

<p align="left">&ensp;&ensp;课程的内容很多，目前也知识了解了皮毛，每一部分的深入还需要更多的时间。这3个月以来，有每周跟老师的视频课，并完成必做作业。但整体下来，对于自己的学习还是满意的。一直很喜欢秦老师的一句话是，只要你做了，你就已经是前30%的人了。在结业之后，接下来的一段时间都会对所学的知识进行复盘，去完善我的脑图，真正的在老师所给的知识框架基础上，建立起属于我自己的知识体系。</p>

<p align="left">&ensp;&ensp;最后感谢秦老师、助教老师和班主任的辛勤付出。</p>

<p align="left">	分别用 100 个字以上的一段话，加上一幅图 (架构图或脑图)，总结自己
对下列技术的关键点思考和经验认识:</p>
1) JVM
<p align="left">	
&ensp;&ensp;jvm是一个抽象的计算模型，通过加载编译的Java字节码，提供了跨平台的功能。jvm内部的分类主要有程序计数器、Java虚拟机栈、本地方法栈、java堆、方法区以及直接内存等，堆内部的分类还要看具体的垃圾回收器。</p>
<p align="left">	
&ensp;&ensp;Java程序要实现计算速度的最大化还要进行调优，主要是由于垃圾回收会造成STW。应用程序会短暂的暂停，所以根据程序运行时调整不同的参数来控制stw的时间，是程序优化很重要的事情。 
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/1.png)
2) NIO
<p align="left">	
&ensp;&ensp;在jdk1.4之前一直都是BIO的操作，BIO即同步阻塞IO，数据的写入和读取都是在一个线程之内完成的，所以他的效率比较低，而且浪费CPU的资源。JDK1.5之后出现了NIO即异步非阻塞IO，有个线程去轮询IO的操作是否完成，这样CPU可以在发出IO操作之后去做其他的事情，不必一直等待操作完成，这样增加了CPU的利用率。
</p>
<p align="left">	
&ensp;&ensp;NIO重要的框架是Netty，Netty简化了原生NIO的一些操作，封装了一些利于理解的东西。利用Netty可以开发高性能网关和RPC等框架。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/2.png)
3) 并发编程
<p align="left">	
&ensp;&ensp;并发主要是充分利用多核cpu的特性，将任务并行处理，增强系统处理的性能。在实际应用场景中，对于业务有着ACID等事务的需求，需要对代码进行相关的处理，另外对于在开发测试调试代码等过程中和平时的单线程开发也有着很大的不同。在实际的项目运行中也会充斥着死锁等问题，对于这些问题，除了知识感觉很多经验也是很必要的，比如打印日志分析相关问题。其实在学了数据库并发的相关知识后，作为和多线程并发一个对比来说，就比较好理解了，比如CopyOnWriteArrayList对应的mysql的事务隔离级别，作为对比思考，就没有那么难理解了。</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/3.png)

4) Spring 和 ORM 等框架
<p align="left">	
&ensp;&ensp;spring是Java语言中最流行的框架，主要是应用了IOC和AOP。所有的bean都有spring容器去管理。后面spring逐渐发展了很多模块，例如spring mvc，spring security等。后面springboot出来以后衍生出了spring cloud为基础的一套微服务全家桶，全面拥抱微服务。

&ensp;&ensp;ORM框架的话主要有hibernate和mybatis，优缺点的话各自都有。mybatis主要是sql自定义，对dba等人比较友好，容易把控。hibernate与数据库的交互上有HQL语言和一些定义好的接口，对dba不是很友好，但是可以在数据库类型切换的时候比mybatis有优势。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/4.png)

5) MySQL 数据库和 SQL
<p align="left">	
&ensp;&ensp;目前主要的数据库有oracle、mysql等，mysql在互联网公司比较多。mysql主要还是事务的ACID特性以及对应的四个隔离级别：读未提交、读提交、可重复读以及可串行化。在前三个隔离级别中还有脏读、不可重复读、幻读等读的问题。要根据业务的并发度以及错误容忍度来进行隔离级别的设定。此外，mysql的log机制也是很重要的，在问题的判断和数据库的备份、主从设定上都需要。

&ensp;&ensp;SQL的话主要是查询的优化，比如查询字段添加索引，字段类型需要匹配等。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/5.png)

6) 分库分表
<p align="left">	
&ensp;&ensp;在业务开发中，数据量小、业务比较初级的时候几张表，一张表几十个字段就可以满足相关的业务需求，但是在数据量逐渐增大，业务逐渐多元化的时候，在数据库的查询上就会使查询变得很慢。如果是单纯的提高访问效率，可以升级到一主多从的架构，写使用master读使用slave，这样分散了数据库读的压力。但是主从架构还是会随着数据量和业务量的增大带来其他的问题。所以要进行分库分表。

&ensp;&ensp;分库分表一般分为垂直拆分和水平拆分，垂直拆分是单个表的字段过多，可以拆成多个表，多个表也可以根据业务精细划分，将表分配到不同的库中。水平拆分是为了应对数据量的增大，一般是对数据库主键按照某种规则进行的，业务需求不同拆分条件也不同。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/6.png)

7) RPC 和微服务
<p align="left">
&ensp;&ensp;单体服务到微服务，单体服务在开发初期会比较简单，很多业务和代码都耦合在一起，但是当系统逐渐发展的时候，很多模块都需要开发升级，这样单体结构就会造成测试和升级的困难。微服务就是将多个模块拆分成不同的系统，利用注册中心等将模块管理起来，中间模块使用RPC或者其他方式进行通信。这样每个开发人员小组只负责相应的模块，升级的时候和其他的模块配合好，也方便了测试。但是要注意微服务不要过度设计，业务比较简单的时候不要设计微服务，本身业务量不大，可能开发人员也不多，造成资源的浪费；还有系统过多的话维护起来比较麻烦，而且系统之间的通信也需要成本的。所以微服务的设计一定要因地制宜。

&ensp;&ensp;在微服务拆分之后，很多事务可能被分成到了两个或者多个服务中，这样还需要对分布式事务进行考虑。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/7.png)

8) 分布式缓存
<p align="left">
&ensp;&ensp;缓存由于是在内存中操作，比访问数据库（数据要从磁盘中读取）要快的多。所以一些热点数据放到缓存中，可以加快接口访问的速度，获得更好的用户体验。使用最多的缓存是redis，redis提供了多种的数据结构，所以redis也可以作为队列、存储地理位置等功能。

&ensp;&ensp;为了保证高可用需要做主从设计，在高并发的情况下还要做缓存集群。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/8.png)

9) 分布式消息队列
<p align="left">
&ensp;&ensp;消息队列的主要作用是异步、解耦、削峰，在不同的场景还有不同的使用方式。
&ensp;&ensp;比如在多个系统之间进行通信的时候，使用的就是异步和解耦功能，一些异步通知使用消息队列，能减少RPC或者是rest调用的时间，同时也使多个系统间解耦。在处理高并发等业务场景的时候，也可以使用消息队列存储大量请求，然后在消费端逐步去消费消息，避免了大量的请求打到业务系统，造成崩溃。
&ensp;&ensp;现在的MQ发展成了多种类型，一般就是根据不同的业务场景去选择不同的消息队列来实现对应的功能。
。
</p>

![](https://github.com/hafizgoo/GeekSummary/blob/main/image/9.png)
